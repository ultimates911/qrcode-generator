// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: links.sql

package sqldb

import (
	"context"
	"time"
)

const createLink = `-- name: CreateLink :one
INSERT INTO links (
  original_url,
  hash,
  user_id,
  name
) VALUES (
  $1, $2, $3, $4
)
RETURNING id, original_url, hash, created_at, updated_at, user_id, name
`

type CreateLinkParams struct {
	OriginalUrl string `json:"original_url"`
	Hash        string `json:"hash"`
	UserID      int64  `json:"user_id"`
	Name        string `json:"name"`
}

func (q *Queries) CreateLink(ctx context.Context, arg CreateLinkParams) (Link, error) {
	row := q.db.QueryRow(ctx, createLink,
		arg.OriginalUrl,
		arg.Hash,
		arg.UserID,
		arg.Name,
	)
	var i Link
	err := row.Scan(
		&i.ID,
		&i.OriginalUrl,
		&i.Hash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.Name,
	)
	return i, err
}

const createQRCode = `-- name: CreateQRCode :one
INSERT INTO qr_codes (
  link_id,
  color,
  background,
  smoothing
) VALUES (
  $1, $2, $3, $4
)
RETURNING id, link_id, color, background, smoothing
`

type CreateQRCodeParams struct {
	LinkID     int64    `json:"link_id"`
	Color      string   `json:"color"`
	Background string   `json:"background"`
	Smoothing  *float64 `json:"smoothing"`
}

func (q *Queries) CreateQRCode(ctx context.Context, arg CreateQRCodeParams) (QrCode, error) {
	row := q.db.QueryRow(ctx, createQRCode,
		arg.LinkID,
		arg.Color,
		arg.Background,
		arg.Smoothing,
	)
	var i QrCode
	err := row.Scan(
		&i.ID,
		&i.LinkID,
		&i.Color,
		&i.Background,
		&i.Smoothing,
	)
	return i, err
}

const createTransition = `-- name: CreateTransition :exec
INSERT INTO transitions (
  link_id,
  country,
  city,
  referer,
  user_agent,
  browser,
  os
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
`

type CreateTransitionParams struct {
	LinkID    int64   `json:"link_id"`
	Country   *string `json:"country"`
	City      *string `json:"city"`
	Referer   *string `json:"referer"`
	UserAgent *string `json:"user_agent"`
	Browser   *string `json:"browser"`
	Os        *string `json:"os"`
}

func (q *Queries) CreateTransition(ctx context.Context, arg CreateTransitionParams) error {
	_, err := q.db.Exec(ctx, createTransition,
		arg.LinkID,
		arg.Country,
		arg.City,
		arg.Referer,
		arg.UserAgent,
		arg.Browser,
		arg.Os,
	)
	return err
}

const deleteLink = `-- name: DeleteLink :execrows
DELETE FROM links WHERE id = $1 AND user_id = $2
`

type DeleteLinkParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) DeleteLink(ctx context.Context, arg DeleteLinkParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteLink, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteQRCodeByLinkID = `-- name: DeleteQRCodeByLinkID :exec
DELETE FROM qr_codes WHERE link_id = $1
`

func (q *Queries) DeleteQRCodeByLinkID(ctx context.Context, linkID int64) error {
	_, err := q.db.Exec(ctx, deleteQRCodeByLinkID, linkID)
	return err
}

const deleteTransitionsByLinkID = `-- name: DeleteTransitionsByLinkID :exec
DELETE FROM transitions WHERE link_id = $1
`

func (q *Queries) DeleteTransitionsByLinkID(ctx context.Context, linkID int64) error {
	_, err := q.db.Exec(ctx, deleteTransitionsByLinkID, linkID)
	return err
}

const getLinkAndQRCodeByID = `-- name: GetLinkAndQRCodeByID :one
SELECT
    l.id,
    l.original_url,
    l.hash,
    l.created_at,
    l.updated_at,
    l.name,
    qc.color,
    qc.background,
    qc.smoothing
FROM
    links l
JOIN
    qr_codes qc ON l.id = qc.link_id
WHERE
    l.id = $1 AND l.user_id = $2
`

type GetLinkAndQRCodeByIDParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

type GetLinkAndQRCodeByIDRow struct {
	ID          int64     `json:"id"`
	OriginalUrl string    `json:"original_url"`
	Hash        string    `json:"hash"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
	Name        string    `json:"name"`
	Color       string    `json:"color"`
	Background  string    `json:"background"`
	Smoothing   *float64  `json:"smoothing"`
}

func (q *Queries) GetLinkAndQRCodeByID(ctx context.Context, arg GetLinkAndQRCodeByIDParams) (GetLinkAndQRCodeByIDRow, error) {
	row := q.db.QueryRow(ctx, getLinkAndQRCodeByID, arg.ID, arg.UserID)
	var i GetLinkAndQRCodeByIDRow
	err := row.Scan(
		&i.ID,
		&i.OriginalUrl,
		&i.Hash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Color,
		&i.Background,
		&i.Smoothing,
	)
	return i, err
}

const getLinkByHash = `-- name: GetLinkByHash :one
SELECT id, original_url, hash, created_at, updated_at, user_id, name FROM links
WHERE hash = $1 LIMIT 1
`

func (q *Queries) GetLinkByHash(ctx context.Context, hash string) (Link, error) {
	row := q.db.QueryRow(ctx, getLinkByHash, hash)
	var i Link
	err := row.Scan(
		&i.ID,
		&i.OriginalUrl,
		&i.Hash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.Name,
	)
	return i, err
}

const getLinksByUserID = `-- name: GetLinksByUserID :many
SELECT id, original_url, name FROM links
WHERE user_id = $1
`

type GetLinksByUserIDRow struct {
	ID          int64  `json:"id"`
	OriginalUrl string `json:"original_url"`
	Name        string `json:"name"`
}

func (q *Queries) GetLinksByUserID(ctx context.Context, userID int64) ([]GetLinksByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getLinksByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLinksByUserIDRow
	for rows.Next() {
		var i GetLinksByUserIDRow
		if err := rows.Scan(&i.ID, &i.OriginalUrl, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLinksSummaryByUser = `-- name: GetLinksSummaryByUser :many
SELECT 
  l.id,
  l.original_url,
  l.name,
  l.created_at,
  COALESCE(COUNT(t.id), 0) AS transitions_count
FROM links l
LEFT JOIN transitions t ON t.link_id = l.id
WHERE l.user_id = $1
GROUP BY l.id
ORDER BY l.created_at DESC
`

type GetLinksSummaryByUserRow struct {
	ID               int64       `json:"id"`
	OriginalUrl      string      `json:"original_url"`
	Name             string      `json:"name"`
	CreatedAt        time.Time   `json:"created_at"`
	TransitionsCount interface{} `json:"transitions_count"`
}

func (q *Queries) GetLinksSummaryByUser(ctx context.Context, userID int64) ([]GetLinksSummaryByUserRow, error) {
	rows, err := q.db.Query(ctx, getLinksSummaryByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLinksSummaryByUserRow
	for rows.Next() {
		var i GetLinksSummaryByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.OriginalUrl,
			&i.Name,
			&i.CreatedAt,
			&i.TransitionsCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransitionsByLinkID = `-- name: GetTransitionsByLinkID :many
SELECT
  t.id,
  t.country,
  t.city,
  t.referer,
  t.user_agent,
  t.browser,
  t.os,
  t.created_at
FROM transitions t
JOIN links l ON l.id = t.link_id
WHERE t.link_id = $1 AND l.user_id = $2
ORDER BY t.created_at DESC
`

type GetTransitionsByLinkIDParams struct {
	LinkID int64 `json:"link_id"`
	UserID int64 `json:"user_id"`
}

type GetTransitionsByLinkIDRow struct {
	ID        int64     `json:"id"`
	Country   *string   `json:"country"`
	City      *string   `json:"city"`
	Referer   *string   `json:"referer"`
	UserAgent *string   `json:"user_agent"`
	Browser   *string   `json:"browser"`
	Os        *string   `json:"os"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) GetTransitionsByLinkID(ctx context.Context, arg GetTransitionsByLinkIDParams) ([]GetTransitionsByLinkIDRow, error) {
	rows, err := q.db.Query(ctx, getTransitionsByLinkID, arg.LinkID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTransitionsByLinkIDRow
	for rows.Next() {
		var i GetTransitionsByLinkIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Country,
			&i.City,
			&i.Referer,
			&i.UserAgent,
			&i.Browser,
			&i.Os,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchLinksByName = `-- name: SearchLinksByName :many
SELECT id, original_url, name FROM links
WHERE user_id = $1 AND name ILIKE '%' || $2 || '%'
`

type SearchLinksByNameParams struct {
	UserID  int64   `json:"user_id"`
	Column2 *string `json:"column_2"`
}

type SearchLinksByNameRow struct {
	ID          int64  `json:"id"`
	OriginalUrl string `json:"original_url"`
	Name        string `json:"name"`
}

func (q *Queries) SearchLinksByName(ctx context.Context, arg SearchLinksByNameParams) ([]SearchLinksByNameRow, error) {
	rows, err := q.db.Query(ctx, searchLinksByName, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchLinksByNameRow
	for rows.Next() {
		var i SearchLinksByNameRow
		if err := rows.Scan(&i.ID, &i.OriginalUrl, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchLinksSummaryByName = `-- name: SearchLinksSummaryByName :many
SELECT 
  l.id,
  l.original_url,
  l.name,
  l.created_at,
  COALESCE(COUNT(t.id), 0) AS transitions_count
FROM links l
LEFT JOIN transitions t ON t.link_id = l.id
WHERE l.user_id = $1 AND l.name ILIKE '%' || $2 || '%'
GROUP BY l.id
ORDER BY l.created_at DESC
`

type SearchLinksSummaryByNameParams struct {
	UserID  int64   `json:"user_id"`
	Column2 *string `json:"column_2"`
}

type SearchLinksSummaryByNameRow struct {
	ID               int64       `json:"id"`
	OriginalUrl      string      `json:"original_url"`
	Name             string      `json:"name"`
	CreatedAt        time.Time   `json:"created_at"`
	TransitionsCount interface{} `json:"transitions_count"`
}

func (q *Queries) SearchLinksSummaryByName(ctx context.Context, arg SearchLinksSummaryByNameParams) ([]SearchLinksSummaryByNameRow, error) {
	rows, err := q.db.Query(ctx, searchLinksSummaryByName, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchLinksSummaryByNameRow
	for rows.Next() {
		var i SearchLinksSummaryByNameRow
		if err := rows.Scan(
			&i.ID,
			&i.OriginalUrl,
			&i.Name,
			&i.CreatedAt,
			&i.TransitionsCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLinkURL = `-- name: UpdateLinkURL :execrows
UPDATE links
SET
    original_url = $1,
    updated_at = now()
WHERE
    id = $2 AND user_id = $3
`

type UpdateLinkURLParams struct {
	OriginalUrl string `json:"original_url"`
	ID          int64  `json:"id"`
	UserID      int64  `json:"user_id"`
}

func (q *Queries) UpdateLinkURL(ctx context.Context, arg UpdateLinkURLParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateLinkURL, arg.OriginalUrl, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateQRCodeParams = `-- name: UpdateQRCodeParams :exec
UPDATE qr_codes
SET
    color = $1,
    background = $2,
    smoothing = $3
WHERE
    link_id = $4
`

type UpdateQRCodeParamsParams struct {
	Color      string   `json:"color"`
	Background string   `json:"background"`
	Smoothing  *float64 `json:"smoothing"`
	LinkID     int64    `json:"link_id"`
}

func (q *Queries) UpdateQRCodeParams(ctx context.Context, arg UpdateQRCodeParamsParams) error {
	_, err := q.db.Exec(ctx, updateQRCodeParams,
		arg.Color,
		arg.Background,
		arg.Smoothing,
		arg.LinkID,
	)
	return err
}
